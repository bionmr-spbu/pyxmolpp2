.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_basics_selections.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_basics_selections.py:



.. |Atom| replace:: :py:class:`~pyxmolpp2.polymer.Atom`
.. |Residue| replace:: :py:class:`~pyxmolpp2.polymer.Residue`
.. |Chain| replace:: :py:class:`~pyxmolpp2.polymer.Chain`
.. |Frame| replace:: :py:class:`~pyxmolpp2.polymer.Frame`

.. |AtomSelection| replace:: :py:class:`~pyxmolpp2.polymer.AtomSelection`
.. |ResidueSelection| replace:: :py:class:`~pyxmolpp2.polymer.ResidueSelection`
.. |ChainSelection| replace:: :py:class:`~pyxmolpp2.polymer.ChainSelection`

.. |AtomPredicate| replace:: :py:class:`~pyxmolpp2.polymer.AtomPredicate`
.. |ResiduePredicate| replace:: :py:class:`~pyxmolpp2.polymer.ResiduePredicate`
.. |ChainPredicate| replace:: :py:class:`~pyxmolpp2.polymer.ChainPredicate`



Selections
----------

*Selection* is ordered set of elements in ``pyxmolpp2``. Order is defined as follows

1. if two elements belongs to same parent object, the order match their construction order
2. otherwise, they ordered as their parents
3. |Frame| references are ordered by :py:attr:`~pyxmolpp2.polymer.Frame.index`



.. code-block:: default
   :lineno-start: 29


    import pyxmolpp2
    import os







Let's create a frame to work with


.. code-block:: default
   :lineno-start: 35


    pdb_filename = os.path.join(os.environ["TEST_DATA_PATH"], "pdb/rcsb/1UBQ.pdb")
    pdb_file = pyxmolpp2.pdb.PdbFile(pdb_filename)

    frame = pdb_file.get_frame()







Library has three types of `selections`: |AtomSelection|, |ResidueSelection| and |ChainSelection|

Construction
^^^^^^^^^^^^

Any selections might be created from |Frame| instance:


.. code-block:: default
   :lineno-start: 48


    print(frame.asChains)
    print(frame.asResidues)
    print(frame.asAtoms)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <pyxmolpp2.polymer.ChainSelection size=2 at 0x00000000020689E0>
    <pyxmolpp2.polymer.ResidueSelection size=134 at 0x0000000001246630>
    <pyxmolpp2.polymer.AtomSelection size=660 at 0x00000000020946B0>



|AtomSelection| and |ResidueSelection| can be created from |Chain|:


.. code-block:: default
   :lineno-start: 55


    chain = frame.asChains[0]
    print(chain.asResidues)
    print(chain.asAtoms)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <pyxmolpp2.polymer.ResidueSelection size=76 at 0x00000000020689E0>
    <pyxmolpp2.polymer.AtomSelection size=602 at 0x000000000207D420>



|AtomSelection| can be created from a |Residue|:


.. code-block:: default
   :lineno-start: 62


    residue = frame.asResidues[0]
    print(residue.asAtoms)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <pyxmolpp2.polymer.AtomSelection size=8 at 0x0000000002076D20>



Conversions
^^^^^^^^^^^

Selections might be converted up and down through hierarchy:


.. code-block:: default
   :lineno-start: 71


    print(chain.asAtoms.asResidues)  # selects non-empty residues
    print(frame.asResidues.asChains)  # selects chains with at least 1 residue
    print(frame.asChains.asResidues.asAtoms.asResidues.asChains)  # select chains with at least 1 non-empty residue





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <pyxmolpp2.polymer.ResidueSelection size=76 at 0x0000000002067440>
    <pyxmolpp2.polymer.ChainSelection size=2 at 0x00000000020689E0>
    <pyxmolpp2.polymer.ChainSelection size=2 at 0x0000000002073680>



Filter
^^^^^^
``filter`` method return new selection with elements that match predicate:



.. code-block:: default
   :lineno-start: 82


    from pyxmolpp2.polymer import AtomName, ResidueName

    chain.asAtoms.filter(lambda a: a.r.x < 0)  # select atoms with negative x coord
    chain.asAtoms.filter(lambda a: a.name == AtomName("CA"))  # select CA atoms
    chain.asResidues.filter(lambda r: r.name == ResidueName("LYS"))  # select LYS residues







``pyxmolpp2`` defines predicate-generators which return predicate when compared to something:



.. code-block:: default
   :lineno-start: 92

    from pyxmolpp2.polymer import aName, rName, aId, rId, cName, cIndex

    frame.asAtoms.filter(aName == "CA")  # select CA atoms
    frame.asResidues.filter(rName == "LYS")  # select LYS residues
    frame.asChains.filter(cName == "A")  # select chain(s) A







|ChainPredicate| and |ResiduePredicate| can be naturally applied to |AtomSelection|,
while |AtomPredicate| can be applied only to |AtomSelection|.


.. code-block:: default
   :lineno-start: 102


    frame.asAtoms.filter(aName == "CA")  # select CA atoms
    frame.asAtoms.filter(rName == "LYS")  # select all atoms of LYS residues







Application of |AtomPredicate| to |ResidueSelection| or |ChainSelection| leads to :py:class:`TypeError` exception.
Same stands for |ResiduePredicate| and |ChainSelection|:


.. code-block:: default
   :lineno-start: 109


    try:
        print(frame.asResidues.filter(aName == "CA"))
    except TypeError as e:
        print(e)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    __call__(): incompatible function arguments. The following argument types are supported:
        1. (self: pyxmolpp2.polymer.AtomPredicate, arg0: pyxmolpp2.polymer.Atom) -> bool

    Invoked with: <pyxmolpp2.polymer.AtomPredicate object at 0x2b64cf0fd260>, <pyxmolpp2.polymer.Residue id=1 name="MET" at 0x0000000002095FE0>




.. code-block:: default
   :lineno-start: 115


    try:
        print(frame.asChains.filter(aName == "CA"))
    except TypeError as e:
        print(e)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    __call__(): incompatible function arguments. The following argument types are supported:
        1. (self: pyxmolpp2.polymer.AtomPredicate, arg0: pyxmolpp2.polymer.Atom) -> bool

    Invoked with: <pyxmolpp2.polymer.AtomPredicate object at 0x2b64cf0fd260>, <pyxmolpp2.polymer.Chain index=0 name="A" at 0x0000000002080820>




.. code-block:: default
   :lineno-start: 121


    try:
        print(frame.asChains.filter(rName == "LYS"))
    except TypeError as e:
        print(e)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    __call__(): incompatible function arguments. The following argument types are supported:
        1. (self: pyxmolpp2.polymer.ResiduePredicate, arg0: pyxmolpp2.polymer.Residue) -> bool
        2. (self: pyxmolpp2.polymer.ResiduePredicate, arg0: pyxmolpp2.polymer.Atom) -> bool

    Invoked with: <pyxmolpp2.polymer.ResiduePredicate object at 0x2b64cf0fd260>, <pyxmolpp2.polymer.Chain index=0 name="A" at 0x0000000002080820>



Predicates can be combined using ``&``, ``|``, ``~`` operators and reused:


.. code-block:: default
   :lineno-start: 131


    from pyxmolpp2.polymer import AtomPredicate

    criteria = (aName == "CA") & rId.is_in({1, 2, 3, 4}) & AtomPredicate(lambda a: a.r.x < 0)  # type:AtomPredicate

    print(frame.asAtoms.filter(criteria | cName.is_in({"X", "Y", "Z"})))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <pyxmolpp2.polymer.AtomSelection size=0 at 0x00000000020BDE50>



Set operations
^^^^^^^^^^^^^^

Selections support set operations:

- `union` (operators ``+``, ``+=``)
- `set intersection` (operators ``*``, ``*=``)
- `difference` (operators ``-``, ``-=``)




.. code-block:: default
   :lineno-start: 148

    A = frame.asAtoms.filter(lambda a: a.r.x > 5)
    B = frame.asAtoms.filter(lambda a: a.r.x <= 5)

    print(A)
    print(B)
    print(A+B)
    print(A-B)
    print(A*B)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <pyxmolpp2.polymer.AtomSelection size=660 at 0x00000000020BFAA0>
    <pyxmolpp2.polymer.AtomSelection size=0 at 0x00000000020C3E40>
    <pyxmolpp2.polymer.AtomSelection size=660 at 0x00000000020AD630>
    <pyxmolpp2.polymer.AtomSelection size=660 at 0x00000000020BD0A0>
    <pyxmolpp2.polymer.AtomSelection size=0 at 0x00000000020AD670>



Invalidation of selection
^^^^^^^^^^^^^^^^^^^^^^^^^

In execution of the program selection may be marked as `invalid`, i.e. further access
to it's elements raises an exception.

Selection gets invalidated on:

- destruction of any of it's elements parent (Primary this happens on deletion of a whole |Frame|.

  .. note::
      The exception will be raised so you will know that you are doing something wrong.

- on :py:attr:`~pyxmolpp2.polymer.Frame.index` change if selection had elements from two frames or more.

  .. danger::
      Currently there is no runtime checks against this type of errors for sake of performance.
      Please make sure you don't do that


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.062 seconds)


.. _sphx_glr_download_auto_examples_basics_selections.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: selections.py <selections.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: selections.ipynb <selections.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
